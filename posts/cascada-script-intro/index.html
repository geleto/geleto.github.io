<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="canonical" href=https://geleto.github.io/posts/cascada-script-intro/>
    <link rel="alternate" type="application/rss+xml" href="/feed.xml" title="Feed">

    <link href="/assets/main.af96226fb914a9e08857.css" rel="stylesheet" />

    <link rel="preconnect" href="https://fonts.gstatic.com">
    <link href="https://fonts.googleapis.com/css2?family=IBM+Plex+Sans&display=swap" rel="stylesheet">

    <title>
      Cascada Script: Parallel by Default, Sequential by Exception
      
         | Angel Popov&#39;s Blog
      
    </title>

    <link rel="icon" type= “image/x-icon” href="/images/favicon.ico">

    <meta property="og:title" content="Cascada Script: Parallel by Default, Sequential by Exception">
    <meta property="og:site_name" content="Angel Popov&#39;s Blog"/>
    <meta property="og:type" content="website"/>
    <meta property="og:url" content="https://geleto.github.io/posts/cascada-script-intro/"/>
    <meta name="twitter:card" content="summary_large_image">

    
      <meta name="twitter:creator" content="@geleto"/>
    

    
    
    
      <meta name="description" content="A scripting language that turns async programming upside down: everything runs in parallel by default, you never write await, and race conditions are impossible by design. Learn how Cascada&#39;s data-driven execution model eliminates async plumbing while maximizing I/O throughput.">
      <meta property="og:description" content="A scripting language that turns async programming upside down: everything runs in parallel by default, you never write await, and race conditions are impossible by design. Learn how Cascada&#39;s data-driven execution model eliminates async plumbing while maximizing I/O throughput.">
      <meta name="description" content="A scripting language that turns async programming upside down: everything runs in parallel by default, you never write await, and race conditions are impossible by design. Learn how Cascada&#39;s data-driven execution model eliminates async plumbing while maximizing I/O throughput."/>
    

    
    
      <meta property="og:image" content="https://geleto.github.io/images/headers/cascada_script_intro_social.jpg"/>
      <meta name="twitter:image" content="https://geleto.github.io/images/headers/cascada_script_intro_social.jpg"/>
    

    
      <script src="https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js"></script>
      <script>mermaid.initialize({startOnLoad:true});</script>
    
  </head>
  <body>
    <div class="layout-wrapper">

      <header class="header">
        <div class="header__content">
          <h1 class="site-title">
            <a href=/>
              Angel Popov&#39;s Blog
            </a>
          </h1>

          
            <nav class="nav">
              <ul class="nav__list">
                
                  
                  

                  

                  

                  <li class="nav-item">
                    <a href="/blog"  >Blog</a>
                  </li>
                
                  
                  

                  

                  

                  <li class="nav-item">
                    <a href="/about"  >About</a>
                  </li>
                
              </ul>
            </nav>

          

        </div>
      </header>

      <main class="main">
        
<article class="post">
  <header class="post__header">
    
      <div class="post__header-image">
        <img src="/images/headers/cascada_script_intro.jpg" alt="Cascada Script: Parallel by Default, Sequential by Exception" class="post__header-img">
      </div>
    
    <h1>Cascada Script: Parallel by Default, Sequential by Exception</h1>
    <div class="post__details">
      <time datetime="2025-10-30">
        30 Oct 2025
      </time>
      <span> | </span>
      <span>7 min read</span>
    </div>
  </header>

  <main class="post__content">
    <p><strong><a href="https://github.com/geleto/cascada/blob/master/docs/cascada/script.md">Cascada Script</a></strong> is a scripting language with JavaScript and TypeScript integration that turns async programming upside down: everything runs in parallel by default, you never write <code>await</code>, and concurrency issues like race conditions are no longer a problem - by design.</p>
<h3>The Nightmare: Callbacks, Promises, and Death by a Thousand <code>await</code>s</h3>
<p>Let's be honest: <code>async/await</code> is a huge improvement for writing asynchronous code. It lets us write clean, sequential-looking logic. But the moment we want to maximize performance, we're forced into a manual balancing act.</p>
<p>We start juggling: &quot;Should I <code>await</code> this call directly? Or should I group these three tasks into a <code>Promise.all</code> to run them in parallel?&quot;</p>
<p>This is where the trouble begins. <code>Promise.all</code> is powerful, but it's a blunt instrument - <strong>it's the programming equivalent of telling everyone to start at exactly the same time and wait for the slowest person to finish.</strong></p>
<p>This &quot;explicit parallelism&quot; model isn't just a quirk of JavaScript; it's the dominant pattern across the entire industry. And here lies the great missed opportunity: tools like LangChain - from its basic RunnableParallel to the stateful, turn-based model of LangGraph—provide powerful graph abstractions that are perfectly suited for implicit dataflow concurrency, yet they don't leverage it. They still expect you to be the concurrency expert. They hand you the tools and expect you to manually identify and orchestrate what can run together. (I'd genuinely love to be proven wrong on this.)</p>
<p>The problems cascade from there:</p>
<ul>
<li>
<p><strong>You start operations before their inputs are ready.</strong> Fire off a request for post comments before you have the post IDs? Your code crashes or makes wasteful, redundant calls.</p>
</li>
<li>
<p><strong>Fast operations are held hostage by slow ones.</strong> You fetch 20 user profiles in parallel - 19 return in 50ms, but one slow API takes 3 seconds. Everything waits. Your fast results sit idle while the clock ticks.</p>
</li>
<li>
<p><strong>Resource bottlenecks emerge.</strong> All your operations hit the same database connection pool simultaneously. Instead of spreading naturally, they queue up and block each other.</p>
</li>
<li>
<p><strong>Complex dependency graphs become impossible to reason about.</strong> User data feeds into both posts AND preferences (which should run in parallel), which then feed into enriched analytics (which must wait for both). Manually orchestrating this with nested <code>await</code>s and carefully placed <code>Promise.all</code> calls turns your clean business logic into brittle async plumbing that breaks when requirements change.</p>
</li>
</ul>
<p>The payoff for getting this right is enormous - optimal orchestration can often cut response times in half or more. But achieving it manually? That's where the complexity becomes daunting.</p>
<p>What if you could just write your code as a straightforward, top-to-bottom script, and let a smart engine handle all the complex concurrent execution for you? That's exactly what <strong><a href="https://github.com/geleto/cascada/blob/master/docs/cascada/script.md">Cascada Script</a></strong> does.</p>
<h2>Let's dive into how it flips the script on async programming.</h2>
<h2>1. ⚡ Parallel by Default</h2>
<p>The most fundamental shift in Cascada is that it's <strong>parallel by default</strong>. In most languages, code runs line by line, one after the other. In Cascada, any independent lines of code run at the same time.</p>
<p>Think about fetching a user's profile and their recent posts. These are two separate operations that don't depend on each other. In traditional JavaScript, you'd need <code>Promise.all</code> to run them concurrently. Cascada does it automatically.</p>
<pre class="language-javascript"><code class="language-javascript"><span class="token comment">// These three operations start at the same time, automatically!</span>
<span class="token keyword">var</span> user <span class="token operator">=</span> <span class="token function">fetchUser</span><span class="token punctuation">(</span><span class="token number">123</span><span class="token punctuation">)</span>
<span class="token keyword">var</span> preferences <span class="token operator">=</span> <span class="token function">getUserPreferences</span><span class="token punctuation">(</span><span class="token number">123</span><span class="token punctuation">)</span>
<span class="token keyword">var</span> analytics <span class="token operator">=</span> <span class="token function">getAnalytics</span><span class="token punctuation">(</span><span class="token number">123</span><span class="token punctuation">)</span>

<span class="token comment">// Build your result with the @ operator</span>
@data<span class="token punctuation">.</span>user <span class="token operator">=</span> user
@data<span class="token punctuation">.</span>preferences <span class="token operator">=</span> preferences
@data<span class="token punctuation">.</span>analytics <span class="token operator">=</span> analytics
<span class="token comment">// Result: { user: {...}, preferences: {...}, analytics: {...} }</span></code></pre>
<p>No <code>Promise.all</code>, no await, no special syntax. If it <em>can</em> run in parallel, it <em>will</em>.</p>
<hr>
<h2>2. 🚦 Data-Driven Flow: Code Runs When Its Inputs Are Ready</h2>
<p>You might be thinking, &quot;What if one operation <em>does</em> depend on another?&quot; Cascada has you covered.</p>
<p>The engine automatically analyzes the data dependencies in your script. An operation will only run once all the variables it needs are ready. This simple rule guarantees the correct order of execution and <strong>completely eliminates race conditions by design</strong>.</p>
<pre class="language-javascript"><code class="language-javascript"><span class="token comment">// 1. This runs first</span>
<span class="token keyword">var</span> user <span class="token operator">=</span> <span class="token function">fetchUser</span><span class="token punctuation">(</span><span class="token number">123</span><span class="token punctuation">)</span>

<span class="token comment">// 2. This depends on 'user', so Cascada waits for it to resolve</span>
<span class="token keyword">var</span> userGreeting <span class="token operator">=</span> <span class="token string">"Hello, "</span> <span class="token operator">+</span> user<span class="token punctuation">.</span>name

<span class="token comment">// 3. Meanwhile, these run in parallel with everything above</span>
<span class="token keyword">var</span> posts <span class="token operator">=</span> <span class="token function">fetchPosts</span><span class="token punctuation">(</span><span class="token number">123</span><span class="token punctuation">)</span>
<span class="token keyword">var</span> comments <span class="token operator">=</span> <span class="token function">fetchComments</span><span class="token punctuation">(</span><span class="token number">123</span><span class="token punctuation">)</span></code></pre>
<p>Here, <code>userGreeting</code> won't be calculated until <code>fetchUser(123)</code> is complete and the <code>user</code> variable has a value. But <code>posts</code> and <code>comments</code> start fetching immediately since they don't depend on <code>user</code>.</p>
<p>No more subtle timing bugs that only appear in production. The engine orchestrates everything automatically.</p>
<hr>
<h2>3. ✨ Implicit Concurrency: Write Business Logic, Not Async Plumbing</h2>
<p>This is where the magic really happens. Notice the lack of <code>await</code> in the examples above? In Cascada, you never have to think about whether a variable holds a value or a promise. You just use it.</p>
<pre class="language-javascript"><code class="language-javascript"><span class="token comment">// Traditional JavaScript: Promise hell</span>
<span class="token keyword">const</span> userPromise <span class="token operator">=</span> <span class="token function">fetchUser</span><span class="token punctuation">(</span><span class="token number">123</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> name <span class="token operator">=</span> <span class="token keyword">await</span> userPromise<span class="token punctuation">.</span>name<span class="token punctuation">;</span> <span class="token comment">// Wait, can't do this!</span>
<span class="token keyword">const</span> actualUser <span class="token operator">=</span> <span class="token keyword">await</span> userPromise<span class="token punctuation">;</span>
<span class="token keyword">const</span> name <span class="token operator">=</span> actualUser<span class="token punctuation">.</span>name<span class="token punctuation">;</span> <span class="token comment">// Finally!</span></code></pre>
<p>Cascada makes this completely invisible:</p>
<pre class="language-javascript"><code class="language-javascript"><span class="token comment">// Cascada: Just use it</span>
<span class="token keyword">var</span> user <span class="token operator">=</span> <span class="token function">fetchUser</span><span class="token punctuation">(</span><span class="token number">123</span><span class="token punctuation">)</span>

<span class="token comment">// The @data command builds our final JSON output</span>
@data<span class="token punctuation">.</span>greet <span class="token operator">=</span> <span class="token string">"Hello, "</span> <span class="token operator">+</span> user<span class="token punctuation">.</span>name
@data<span class="token punctuation">.</span>email <span class="token operator">=</span> user<span class="token punctuation">.</span>email
@data<span class="token punctuation">.</span>status <span class="token operator">=</span> user<span class="token punctuation">.</span>isActive <span class="token operator">?</span> <span class="token string">"active"</span> <span class="token operator">:</span> <span class="token string">"inactive"</span></code></pre>
<p>Forget <code>.then()</code> and forget manually tracking promises. Cascada handles the asynchronous state invisibly under the hood. You can pass a &quot;future value&quot; (a promise) into a function or use it in an expression, and it just works.</p>
<p>This lets you focus entirely on your business logic, not the async plumbing.</p>
<hr>
<h2>4. ➡️ Implicitly Parallel, Explicitly Sequential</h2>
<p>Of course, sometimes you absolutely need things to happen in a specific order, especially when dealing with operations that have side effects - like writing to a database or making stateful API calls.</p>
<p>For these cases, Cascada provides a simple escape hatch: the <code>!</code> marker. Marking a call or path with <code>!</code> enforces a strict sequential order on that specific path, without slowing down the rest of your script. A call does not need a data dependency from another to run in sequence.</p>
<pre class="language-javascript"><code class="language-javascript"><span class="token comment">// The ! marker creates a sequential chain for a specific path</span>
<span class="token keyword">var</span> account <span class="token operator">=</span> <span class="token function">getBankAccount</span><span class="token punctuation">(</span><span class="token punctuation">)</span>

<span class="token comment">// 1. This MUST finish first</span>
account<span class="token operator">!</span><span class="token punctuation">.</span><span class="token function">deposit</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span>
<span class="token comment">// 2. This waits for deposit to complete</span>
account<span class="token punctuation">.</span><span class="token function">getStatus</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token comment">// 3. This waits for getStatus</span>
account<span class="token operator">!</span><span class="token punctuation">.</span><span class="token function">withdraw</span><span class="token punctuation">(</span><span class="token number">50</span><span class="token punctuation">)</span>

<span class="token comment">// Meanwhile, these run in parallel with everything above</span>
<span class="token keyword">var</span> preferences <span class="token operator">=</span> <span class="token function">getUserPreferences</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
preferences<span class="token operator">!</span><span class="token punctuation">.</span><span class="token function">update</span><span class="token punctuation">(</span>prefs<span class="token punctuation">)</span>   <span class="token comment">// Sequential chain for preferences too</span>
<span class="token keyword">var</span> analytics <span class="token operator">=</span> <span class="token function">fetchAnalytics</span><span class="token punctuation">(</span><span class="token punctuation">)</span></code></pre>
<p>The <code>!</code> creates a sequential chain for just that specific path, without affecting the parallelism of everything else. It's <strong>parallel by default, sequential by exception</strong> - the opposite of traditional programming.</p>
<hr>
<h2>5. 📋 Chaotic Execution, Predictable Output</h2>
<p>While independent operations run in parallel and can finish in any order, Cascada guarantees that your <strong>final output is assembled predictably</strong>.</p>
<p>Data manipulation commands (like adding an item to a list) are applied in the exact order they appear in your script. So even if a <code>for</code> loop's iterations complete out of order, the final array will be structured correctly.</p>
<pre class="language-javascript"><code class="language-javascript"><span class="token keyword">var</span> userIds <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">101</span><span class="token punctuation">,</span> <span class="token number">102</span><span class="token punctuation">,</span> <span class="token number">103</span><span class="token punctuation">]</span>

<span class="token comment">// All three fetchUserDetails calls run in parallel</span>
<span class="token comment">// Maybe user 103's data comes back first</span>
<span class="token keyword">for</span> id <span class="token keyword">in</span> userIds
  <span class="token keyword">var</span> details <span class="token operator">=</span> <span class="token function">fetchUserDetails</span><span class="token punctuation">(</span>id<span class="token punctuation">)</span>
  @data<span class="token punctuation">.</span>users<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>details<span class="token punctuation">.</span>name<span class="token punctuation">)</span>
endfor

<span class="token comment">// Even so, the final output is ALWAYS predictable and in order:</span>
<span class="token comment">// { "users": ["Alice", "Bob", "Charlie"] }</span></code></pre>
<p>This gives you the best of both worlds: maximum I/O performance from parallel execution, with the reliability of sequential data assembly.</p>
<hr>
<h2>6. ☣️ Dataflow Poisoning: Resilient Error Handling</h2>
<p>Traditional <code>try/catch</code> blocks don't work well in a massively parallel system. If one of fifty concurrent API calls fails, should everything stop?</p>
<p>Cascada uses a more resilient model called <strong>dataflow poisoning</strong>. When an operation fails, it doesn't throw an exception; it produces an <code>Error Value</code>. This error then &quot;poisons&quot; any other variable or operation that depends on it. Crucially, unrelated operations continue running completely unaffected.</p>
<pre class="language-javascript"><code class="language-javascript"><span class="token comment">// Let's pretend fetchPosts() fails, but fetchUser() succeeds</span>
<span class="token keyword">var</span> user <span class="token operator">=</span> <span class="token function">fetchUser</span><span class="token punctuation">(</span><span class="token number">123</span><span class="token punctuation">)</span>            <span class="token comment">// ✅ Succeeds</span>
<span class="token keyword">var</span> posts <span class="token operator">=</span> <span class="token function">fetchPosts</span><span class="token punctuation">(</span><span class="token number">123</span><span class="token punctuation">)</span>          <span class="token comment">// ❌ Fails and becomes an Error Value</span>
<span class="token keyword">var</span> comments <span class="token operator">=</span> <span class="token function">fetchComments</span><span class="token punctuation">(</span>posts<span class="token punctuation">)</span>  <span class="token comment">// ☣️ Poisoned because it uses 'posts'</span>

<span class="token comment">// Now, let's see what happens:</span>
@data<span class="token punctuation">.</span>userName <span class="token operator">=</span> user<span class="token punctuation">.</span>name     <span class="token comment">// ✅ Works fine, uses the successful result</span>
@data<span class="token punctuation">.</span>postCount <span class="token operator">=</span> posts<span class="token punctuation">.</span>length <span class="token comment">// ❌ Becomes an error because 'posts' is poisoned</span>

<span class="token comment">// You can check for errors and provide fallbacks</span>
<span class="token keyword">if</span> posts is error
  posts <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>  <span class="token comment">// Assign a default value</span>
endif

@data<span class="token punctuation">.</span>postCount <span class="token operator">=</span> posts<span class="token punctuation">.</span>length <span class="token comment">// ✅ Now works with our fallback</span></code></pre>
<p>This approach isolates failures, prevents corrupted data from producing incorrect results, and makes your workflows incredibly robust.</p>
<p>The beauty of dataflow poisoning is that you have <strong>complete control over recovery</strong>. You can detect errors at any point in your workflow (using <code>is error</code> conditions), repair them with fallback values, log them for monitoring, or even retry failed operations - all while the rest of your script continues executing normally.</p>
<hr>
<h2>7. 💡 Clean, Expressive Syntax</h2>
<p>Cascada offers a clean, expressive syntax that will feel instantly familiar if you know JavaScript. You can use variables, loops, conditionals, and build reusable macros.</p>
<pre class="language-javascript"><code class="language-javascript"><span class="token comment">// Variables, conditionals, loops</span>
<span class="token keyword">var</span> discount <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>

<span class="token keyword">if</span> userType <span class="token operator">==</span> <span class="token string">"premium"</span>
  <span class="token keyword">var</span> discount <span class="token operator">=</span> <span class="token number">0.10</span>
endif

<span class="token comment">// Build reusable macros</span>
macro <span class="token function">formatPrice</span><span class="token punctuation">(</span>amount<span class="token punctuation">,</span> discount<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">)</span>
  <span class="token keyword">var</span> final <span class="token operator">=</span> amount <span class="token operator">*</span> <span class="token punctuation">(</span><span class="token number">1</span> <span class="token operator">-</span> discount<span class="token punctuation">)</span>
  @text <span class="token operator">&lt;&lt;</span> <span class="token string">"$"</span> <span class="token operator">+</span> final
endmacro

<span class="token function">formatPrice</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">,</span> discount<span class="token punctuation">)</span>  <span class="token comment">// Outputs: $90</span></code></pre>
<p>You get variables (<code>var</code>), conditionals (<code>if/else</code>), loops (<code>for/while</code>), macros for reusability (<code>macro</code>), and modular code organization with <code>import</code> and <code>extends</code>.</p>
<hr>
<h2>8. ⚙️ Under the Hood: Chaos Managed Gracefully</h2>
<p>Underneath all this simplicity is a powerful engine that:</p>
<ul>
<li><strong>Tracks data dependencies automatically</strong> so operations run when their inputs are ready</li>
<li><strong>Handles concurrent execution safely</strong> with maximum I/O throughput</li>
<li><strong>Guarantees consistent, deterministic outputs</strong> even with chaotic parallel execution</li>
<li><strong>Propagates errors without crashing</strong> so failures are isolated and manageable</li>
</ul>
<p>You focus on <em>what</em> you want to happen. The engine handles <em>how</em> to make it happen safely and efficiently.</p>
<hr>
<h2>🎯 Why This Matters</h2>
<p>Cascada isn't trying to replace JavaScript - it's designed to be the backbone of your data layer.</p>
<p>Use it to compose complex workflows that wire together LLMs, APIs, databases, and external services. By inverting the traditional programming model - parallel by default, sequential by exception - it lets you build high-performance data pipelines that are surprisingly simple and intuitive all with maximum I/O throughput and minimum mental overhead.</p>
<p>The result? <strong>Code that reads like synchronous logic but executes with the performance of carefully orchestrated async operations.</strong> You get to focus on <em>what</em> you're building instead of <em>how</em> to manage promises, race conditions, and execution order.</p>
<p>And the best part? When you look at your Cascada script six months later, you'll actually understand what it does.</p>
<hr>
<h2>🚀 Ready to Simplify Your Async Code?</h2>
<p>Cascada is <code>a work in progress</code> under active development and evolving quickly. Install it with:</p>
<pre class="language-bash"><code class="language-bash"><span class="token function">npm</span> <span class="token function">install</span> cascada-engine</code></pre>
<p>And start writing async code that makes sense:</p>
<pre class="language-javascript"><code class="language-javascript"><span class="token keyword">import</span> <span class="token punctuation">{</span> AsyncEnvironment <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'cascada-engine'</span><span class="token punctuation">;</span>

<span class="token keyword">const</span> env <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">AsyncEnvironment</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> script <span class="token operator">=</span> <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">
  var user = fetchUser(123)
  var posts = fetchPosts(user.id)

  @data.welcome = "Hello, " + user.name
  @data.postCount = posts.length
</span><span class="token template-punctuation string">`</span></span><span class="token punctuation">;</span>

<span class="token keyword">const</span> result <span class="token operator">=</span> <span class="token keyword">await</span> env<span class="token punctuation">.</span><span class="token function">renderScriptString</span><span class="token punctuation">(</span>script<span class="token punctuation">,</span> context<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// { welcome: 'Hello, Alice', postCount: 42 }</span></code></pre>
<p><strong>⚠️ Heads up!</strong> Cascada is a new project. You might run into bugs, and the documentation is catching up with the code. Your feedback and contributions are welcome as we build the future of asynchronous programming.</p>
<hr>
<h2>Final Thoughts</h2>
<p>If you've ever fought through promise hell, callback pyramids, or race conditions, Cascada might just feel like magic.</p>
<p>It turns async programming from a juggling act into a walk in the park. You write code like a human - simple, sequential, intuitive - and let the runtime handle the parallelism and safety behind the scenes.</p>
<p>The future of async programming isn't about getting better at promises. It's about not having to think about them at all.</p>

  </main>

  <aside class="post__aside">
    <div class="post__tags">
      
        
        <a href="/tags/cascada/">#cascada</a>
      
        
        <a href="/tags/async/">#async</a>
      
        
        <a href="/tags/concurrency/">#concurrency</a>
      
        
        <a href="/tags/parallel-programming/">#parallel-programming</a>
      
        
        <a href="/tags/javascript/">#javascript</a>
      
        
        <a href="/tags/typescript/">#typescript</a>
      
        
        <a href="/tags/dataflow/">#dataflow</a>
      
    </div>

    <nav class="post__pagination">

        <a href="/posts/cascada-kitchen-chef/">
          <span>The Kitchen Chef&#39;s Guide to Concurrent Programming with Cascada</span>
          <span>→</span>
        </a>

      
    </nav>
  </aside>

</article>
      </main>

      <footer class="footer">
        <div class="footer__content">

          <ul class="hero__social-links">
            
              
                

                
                  
                

                <li>
                  <a href="https://github.com/geleto" target="_blank" rel="noopener noreferrer" >GitHub</a>
                </li>
              
                

                
                  
                

                <li>
                  <a href="https://x.com/thegeletohttps://twitter.com/" target="_blank" rel="noopener noreferrer" >X</a>
                </li>
              
                

                
                  
                

                <li>
                  <a href="https://www.linkedin.com/in/angel-popov/" target="_blank" rel="noopener noreferrer" >LinkedIn</a>
                </li>
              
                

                
                  
                

                <li>
                  <a href="https://www.facebook.com/geleto" target="_blank" rel="noopener noreferrer" >Facebook</a>
                </li>
              
            

            

              
                

                
                  
                

                <li>
                  <a href="/feed.xml" target="_blank" rel="noopener noreferrer" >RSS</a>
                </li>
              
            
          </ul>

          
            <p class="footer__attribution">
              <a href="https://www.11ty.dev" target="_blank" rel="noopener">11ty</a> <a href="https://github.com/yinkakun/eleventy-duo" target="_blank" rel="noopener noreferrer"> theme </a> by <a href="https://twitter.com/yinkakun" target="_blank" rel="noopener">Yinka,</a>
            </p>
          

        </div>
      </div>

    </footer>

    <script src="/assets/main.31d6cfe0d16ae931b73c.js"></script>
  </body>
</html>
